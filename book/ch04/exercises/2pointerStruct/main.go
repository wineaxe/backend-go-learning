package main

import (
	"fmt"
)

// Определение структуры myStructure с тремя полями
type myStructure struct {
	Name string // имя

	Surname string // фамилия

	Height int32 // рост в см
}

// createStruct возвращает УКАЗАТЕЛЬ на структуру (*myStructure)
// Преимущество: не копирует структуру, возвращает только адрес (8 байт на 64-битной системе)
func createStruct(n, s string, h int32) *myStructure {

	// Валидация: если рост больше 300 см, считаем это ошибкой и ставим 0
	if h > 300 {

		h = 0
	}

	// &myStructure{n, s, h} — создаём структуру и возвращаем указатель на неё
	// Структура будет размещена в куче (heap), так как указатель на неё возвращается из функции
	return &myStructure{n, s, h}
}

// retStructure возвращает структуру ПО ЗНАЧЕНИЮ (myStructure)
// Недостаток: копирует всю структуру при возврате (может быть затратно для больших структур)
func retStructure(n, s string, h int32) myStructure {

	if h > 300 {

		h = 0
	}

	// Возвращаем структуру напрямую (копия будет создана)
	return myStructure{n, s, h}
}

func main() {

	// Вызываем функцию, которая возвращает указатель на структуру
	s1 := createStruct("Mihalis", "Tsoukalos", 123)
	// s1 имеет тип *myStructure (указатель)

	s2 := createStruct("Mihalis", "Tsoukalos", 123)
	// s2 тоже указатель на структуру

	// ЯВНОЕ разыменование указателя: (*s1).Name
	// *s1 — получаем структуру, затем .Name — обращаемся к полю
	fmt.Println((*s1).Name) // Mihalis

	// АВТОМАТИЧЕСКОЕ разыменование: s2.Name
	// Go автоматически разыменовывает указатель при доступе к полю
	// s2.Name эквивалентно (*s2).Name, но короче и идиоматичнее
	fmt.Println(s2.Name) // Mihalis

	// Вывод указателя: показывает адрес памяти и значения структуры
	fmt.Println(s1) // &{Mihalis Tsoukalos 123} — & означает указатель

	fmt.Println(s2) // &{Mihalis Tsoukalos 123} — другой адрес памяти (другая структура)
	// Важно: s1 и s2 указывают на РАЗНЫЕ структуры, даже если значения одинаковые

	fmt.Println("\n=== ПРИМЕРЫ СРАВНЕНИЯ УКАЗАТЕЛЕЙ ===")

	// СРАВНЕНИЕ УКАЗАТЕЛЕЙ (сравниваются АДРЕСА, а не значения)
	fmt.Println("s1 == s2:", s1 == s2) // false — разные адреса памяти

	// Сравнение ЗНАЧЕНИЙ структур (разыменовываем указатели)
	fmt.Println("*s1 == *s2:", *s1 == *s2) // true — значения одинаковые

	// Создаём третий указатель, указывающий на ту же структуру, что и s1
	s3 := s1 // s3 теперь указывает на ту же структуру, что и s1
	fmt.Println("s1 == s3:", s1 == s3)     // true — одинаковые адреса
	fmt.Println("*s1 == *s3:", *s1 == *s3) // true — и значения тоже одинаковые

	// Изменяем структуру через s3
	s3.Name = "John"
	fmt.Println("После s3.Name = 'John':")
	fmt.Println("s1.Name:", s1.Name) // John — изменилось! (s1 и s3 указывают на одно и то же)
	fmt.Println("s3.Name:", s3.Name) // John

	fmt.Println("\n=== ПРИМЕРЫ С nil УКАЗАТЕЛЯМИ ===")

	// Создаём nil указатель
	var s4 *myStructure // nil по умолчанию
	fmt.Println("s4 == nil:", s4 == nil) // true

	// БЕЗОПАСНАЯ проверка перед использованием
	if s4 != nil {
		fmt.Println("s4.Name:", s4.Name)
	} else {
		fmt.Println("s4 is nil, нельзя обращаться к полям!")
	}

	// Инициализируем указатель
	s4 = createStruct("Alice", "Smith", 170)
	fmt.Println("После инициализации s4:", s4) // &{Alice Smith 170}
	fmt.Println("s4 == nil:", s4 == nil)        // false

	// Теперь можно безопасно использовать
	fmt.Println("s4.Name:", s4.Name) // Alice

	// Пример функции, которая может вернуть nil
	s5 := getStructOrNil("Bob", "Jones", 180)
	if s5 != nil {
		fmt.Println("s5.Name:", s5.Name) // Bob
	} else {
		fmt.Println("s5 is nil")
	}

	// Пример с невалидными данными (вернёт nil)
	s6 := getStructOrNil("Invalid", "Data", 500) // рост > 300
	if s6 != nil {
		fmt.Println("s6.Name:", s6.Name)
	} else {
		fmt.Println("s6 is nil (невалидные данные)") // это выведется
	}
}

// Вспомогательная функция для демонстрации: возвращает nil при невалидных данных
func getStructOrNil(n, s string, h int32) *myStructure {
	if h > 300 {
		return nil // возвращаем nil вместо структуры
	}
	return &myStructure{n, s, h}
}

// ТОНКОСТИ УКАЗАТЕЛЕЙ НА СТРУКТУРЫ:
//
// 1. АВТОМАТИЧЕСКОЕ РАЗЫМЕНОВАНИЕ:
//    - s.Name эквивалентно (*s).Name (Go делает это автоматически)
//    - Можно писать короче: s.Name вместо (*s).Name
//
// 2. ВОЗВРАТ УКАЗАТЕЛЯ vs ЗНАЧЕНИЯ:
//    - *myStructure — возвращает указатель (8 байт), структура в куче
//    - myStructure — возвращает копию структуры (может быть много байт)
//    - Для больших структур указатель эффективнее
//
// 3. ИЗМЕНЕНИЕ ЧЕРЕЗ УКАЗАТЕЛЬ:
//    - Изменение поля через указатель влияет на оригинал
//    - Изменение копии структуры не влияет на оригинал
//
// 4. СРАВНЕНИЕ УКАЗАТЕЛЕЙ:
//    - s1 == s2 сравнивает АДРЕСА, а не значения структур
//    - Даже если структуры идентичны, указатели разные → false
//    - Для сравнения значений нужно: *s1 == *s2
//
// 5. nil УКАЗАТЕЛЬ:
//    - Указатель может быть nil (не указывать никуда)
//    - Попытка доступа к полю через nil указатель вызовет панику
//    - Всегда проверяйте на nil перед использованием
//
// 6. ПРОИЗВОДИТЕЛЬНОСТЬ:
//    - Указатели избегают копирования больших структур
//    - Но добавляют уровень косвенности (разыменование)
//    - Для маленьких структур (несколько полей) разница незначительна
