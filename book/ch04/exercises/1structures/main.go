package main

import (
	"fmt"
)

func main() {

	// ОПРЕДЕЛЕНИЕ СТРУКТУРЫ
	// type Имя struct { поля }
	// Структура — это пользовательский тип, объединяющий несколько полей разных типов
	type XYZ struct {
		X int // поле X типа int
		Y int // поле Y типа int
		Z int // поле Z типа int
	}
	// Тонкость: поля с маленькой буквы (x, y, z) — приватные (доступны только в том же пакете)
	// Поля с большой буквы (X, Y, Z) — публичные (доступны из других пакетов)

	// ИНИЦИАЛИЗАЦИЯ С НУЛЕВЫМИ ЗНАЧЕНИЯМИ
	// var s1 XYZ — создаёт переменную типа XYZ со всеми полями, равными нулевым значениям их типов
	var s1 XYZ
	// Для int нулевое значение = 0, поэтому s1 = {X: 0, Y: 0, Z: 0}

	fmt.Println(s1.Y, s1.Z) // 0 0 — обращение к полям через точку

	// ПОЗИЦИОННАЯ ИНИЦИАЛИЗАЦИЯ (порядок важен!)
	// XYZ{23, 12, -2} — значения присваиваются полям в порядке их объявления
	p1 := XYZ{23, 12, -2}
	// p1.X = 23, p1.Y = 12, p1.Z = -2

	// ИМЕНОВАННАЯ ИНИЦИАЛИЗАЦИЯ (порядок не важен, можно пропускать поля)
	// XYZ{Z: 12, Y: 13} — указываем конкретные поля, остальные получают нулевые значения
	p2 := XYZ{Z: 12, Y: 13}
	// p2.Z = 12, p2.Y = 13, p2.X = 0 (не указано, поэтому нулевое значение)

	fmt.Println(p1) // {23 12 -2} — вывод структуры в формате {X Y Z}

	fmt.Println(p2) // {0 13 12} — порядок полей в выводе соответствует объявлению

	// МАССИВ СТРУКТУР
	// [4]XYZ{} — массив из 4 элементов типа XYZ, все инициализированы нулевыми значениями
	pSlice := [4]XYZ{}
	// pSlice[0] = {0, 0, 0}, pSlice[1] = {0, 0, 0}, и т.д.

	// Присваивание структур в массив
	pSlice[2] = p1 // копируем p1 в элемент массива с индексом 2
	pSlice[0] = p2 // копируем p2 в элемент массива с индексом 0

	fmt.Println(pSlice)
	// Вывод: [{0 13 12} {0 0 0} {23 12 -2} {0 0 0}]

	// ВАЖНАЯ ТОНКОСТЬ: структуры копируются ПО ЗНАЧЕНИЮ, а не по ссылке!
	// Изменение p2 НЕ повлияет на pSlice[0], так как это была копия
	p2 = XYZ{1, 2, 3} // изменяем p2

	fmt.Println(pSlice) // [{0 13 12} {0 0 0} {23 12 -2} {0 0 0}] — массив НЕ изменился!
	// pSlice[0] остался прежним, потому что структуры копируются по значению
}

// ТОНКОСТИ СТРУКТУР В GO:
//
// 1. НУЛЕВЫЕ ЗНАЧЕНИЯ:
//    - При создании var s XYZ все поля получают нулевые значения своих типов
//    - int → 0, string → "", bool → false, указатели → nil
//
// 2. КОПИРОВАНИЕ:
//    - Структуры копируются ПО ЗНАЧЕНИЮ (все поля копируются)
//    - Изменение копии не влияет на оригинал
//    - Для больших структур это может быть затратно по памяти
//
// 3. СРАВНЕНИЕ:
//    - Структуры можно сравнивать операторами == и !=
//    - Сравниваются все поля по порядку
//    - НО: если структура содержит несравнимые типы (срезы, карты, функции), сравнение невозможно
//
// 4. ПУБЛИЧНОСТЬ:
//    - Поля с большой буквы (X, Y, Z) — публичные (экспортируемые)
//    - Поля с маленькой буквы (x, y, z) — приватные (только внутри пакета)
//
// 5. ВЛОЖЕННЫЕ СТРУКТУРЫ:
//    - Можно вкладывать структуры друг в друга
//    - Доступ к полям: outer.inner.field или outer.field (если нет конфликта имён)
//
// 6. УКАЗАТЕЛИ НА СТРУКТУРЫ:
//    - &XYZ{1, 2, 3} — создаёт указатель на структуру
//    - Изменение через указатель влияет на оригинал
//    - Часто используется для эффективности (избегает копирования)
