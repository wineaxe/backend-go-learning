package main

import (
	"fmt"
)

func main() {

	// ПРИМЕР 1: Создание карты через make
	// make(map[тип_ключа]тип_значения) создаёт пустую карту
	iMap := make(map[string]int) // карта: ключи — строки, значения — целые числа

	// Добавление элементов в карту: map[ключ] = значение
	iMap["k1"] = 12 // добавляем пару "k1" -> 12

	iMap["k2"] = 13 // добавляем пару "k2" -> 13

	fmt.Println("iMap:", iMap) // map[k1:12 k2:13] — порядок может быть любым (карта неупорядочена)

	// ПРИМЕР 2: Создание карты литералом (с начальными значениями)
	anotherMap := map[string]int{

		"k1": 12, // пара ключ-значение
		"k2": 13,
	}

	fmt.Println("anotherMap:", anotherMap) // map[k1:12 k2:13]

	// ПРИМЕР 3: Удаление элементов из карты
	delete(anotherMap, "k1") // удаляем элемент с ключом "k1"

	delete(anotherMap, "k1") // повторное удаление того же ключа — безопасно, ничего не произойдёт

	delete(anotherMap, "k1") // можно вызывать delete для несуществующего ключа — ошибки не будет

	fmt.Println("anotherMap:", anotherMap) // map[k2:13] — "k1" удалён

	// ПРИМЕР 4: Проверка существования ключа в карте
	// При обращении к карте возвращаются два значения:
	// value — значение (или нулевое значение типа, если ключа нет)
	// ok — булево значение: true если ключ существует, false если нет
	_, ok := iMap["k2"] // _ игнорирует значение, ok — флаг существования

	if ok {

		fmt.Println("Exists!") // если ключ найден

	} else {

		fmt.Println("Does NOT exist") // если ключа нет в карте
	}
	// Результат: "Does NOT exist", так как ключа "doesItExist" нет в iMap

	// ПРИМЕР 5: Перебор всех элементов карты через range
	// for key, value := range map — перебирает все пары ключ-значение
	// Порядок перебора не гарантирован (карта неупорядочена)
	for key, value := range iMap {

		fmt.Println(key, value) // выводит каждую пару ключ-значение
	}
	// Может вывести:
	// k1 12
	// k2 13
	// или наоборот (порядок случайный)
}
