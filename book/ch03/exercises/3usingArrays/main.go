package main // объявление пакета: точка входа в программу

import "fmt" // пакет для вывода

func main() {
	// Одномерный массив: 4 целых числа, размер фиксирован навсегда
	anArray := [4]int{1, 2, 4, -4}

	// Двумерный массив (матрица 4×4): массив из 4 массивов по 4 int
	twoD := [4][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}

	// Трёхмерный массив: 2 "слоя", в каждом слой 2×2 (объём 2×2×2)
	threeD := [2][2][2]int{{{1, 0}, {-2, 4}}, {{5, -1}, {7, 0}}}

	// len(массив) — длина (количество элементов); для anArray это 4
	fmt.Println("The length of anArray of", anArray, "is", len(anArray))

	// Обращение по индексам: twoD[0][0] — первая строка, первый столбец (значение 1)
	fmt.Println("The first element of", twoD, "is", twoD[0][0])

	// len(threeD) — длина "внешнего" измерения, т.е. 2 (два "слоя")
	fmt.Println("The length of", threeD, "is", len(threeD))

	// Перебор трёхмерного массива по индексам (три вложенных цикла)
	for i := 0; i < len(threeD); i++ { // i — индекс первого измерения (слои)

		v := threeD[i] // v — один "слой", тип [2][2]int

		// Было: for j := 0; i < len(v); j++  — в условии стояло i вместо j → бесконечный цикл (i в этом цикле не меняется)
		for j := 0; j < len(v); j++ { // исправлено: j < len(v)

			m := v[j] // m — одна строка внутри слоя, тип [2]int

			for k := 0; k < len(m); k++ { // k — индекс третьего измерения

				fmt.Print(m[k], " ") // печатаем элемент и пробел

			}

		}

		fmt.Println() // после каждого слоя — перевод строки

	}

	// Тот же перебор, но через range: индекс не нужен, используем _ (пустой идентификатор)
	for _, v := range threeD { // _ — игнорируем индекс слоя, v — значение (слой [2][2]int)

		for _, m := range v { // _ — игнорируем индекс, m — строка [2]int

			for _, s := range m { // _ — игнорируем индекс, s — одно число (int)

				fmt.Print(s, " ")

			}

		}

		fmt.Println()

	}

}
